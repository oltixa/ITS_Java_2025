# Контрольні питання

## 1. Що таке структурне програмування?

**Структурне програмування** - це парадигма програмування, яка базується на використанні структурованих конструкцій управління потоком виконання програми.

### Основні характеристики:
- Використання послідовності, розгалуження та циклів
- Уникнення неструктурованих переходів (goto)
- Розбиття програми на логічні блоки
- Покращення читабельності та підтримуваності коду

## 2. Основні конструкції структурного програмування

### Три базові конструкції:

1. **Послідовність (Sequence)**
   - Виконання інструкцій одна за одною
   ```java
   int a = 5;
   int b = 10;
   int c = a + b;
   ```

2. **Розгалуження (Selection)**
   - `if`, `if-else`, `switch`
   ```java
   if (condition) {
       // код
   } else {
       // альтернативний код
   }
   ```

3. **Повторення (Iteration)**
   - `while`, `do-while`, `for`
   ```java
   for (int i = 0; i < 10; i++) {
       // повторюваний код
   }
   ```

## 3. Основні принципи структурного програмування

1. **Принцип єдиного входу та виходу**
   - Кожен блок має одну точку входу і одну точку виходу

2. **Модульність**
   - Розбиття програми на невеликі, зрозумілі модулі

3. **Уникнення goto**
   - Використання структурованих конструкцій замість неконтрольованих переходів

4. **Top-down підхід**
   - Проектування від загального до конкретного

5. **Локальність даних**
   - Обмеження області видимості змінних

## 4. Чому не рекомендується GOTO, а в Java його немає?

### Проблеми з GOTO:
- **Спагеті-код**: створює заплутані, непідтримувані програми
- **Порушення структури**: ускладнює розуміння логіки програми
- **Труднощі налагодження**: складно відстежити потік виконання
- **Порушення принципів**: суперечить структурному програмуванню

### Чому Java не має GOTO:
- Java розроблялася як сучасна мова з чистою архітектурою
- Всі потреби GOTO покриваються структурованими конструкціями
- Забезпечення безпеки та читабельності коду
- Підтримка об'єктно-орієнтованих принципів

## 5. Що таке спагеті-код?

**Спагеті-код** - це програмний код із заплутаною, неструктурованою логікою, який важко читати, розуміти та підтримувати.

### Характеристики:
- Хаотичні переходи між різними частинами програми
- Відсутність чіткої структури
- Використання множественних goto або аналогічних конструкцій
- Складність відстеження потоку виконання

### Приклад проблематичного коду:
```java
// Погано структурований код
if (condition1) goto label1;
if (condition2) goto label2;
label1: // код
goto label3;
label2: // інший код  
label3: // ще код
```

## 6. Проектування зверху-вниз (Top-Down)

### Визначення:
**Top-down підхід** - методологія розробки, при якій система проектується від загальних концепцій до конкретних деталей.

### Процес:
1. Визначення загальної мети програми
2. Розбиття на основні функціональні блоки
3. Деталізація кожного блоку
4. Подальша декомпозиція до елементарних операцій

### Переваги:
- **Структурованість**: чітка ієрархія компонентів
- **Керованість**: легше контролювати складність
- **Тестування**: можливість поетапного тестування
- **Командна робота**: розподіл завдань між розробниками
- **Розуміння**: краще розуміння архітектури системи

## 7. Область видимості ідентифікатора

**Область видимості (Scope)** - це частина програми, в якій ідентифікатор (змінна, метод, клас) є доступним для використання.

### Типи областей видимості в Java:
- **Блокова**: всередині фігурних дужок `{}`
- **Методова**: всередині методу
- **Класова**: всередині класу
- **Пакетова**: всередині пакету
- **Глобальна**: доступ з будь-якого місця (public)

## 8. Блоки та їх вплив на область видимості

### Що таке блок:
**Блок** - це група операторів, об'єднаних фігурними дужками `{}`.

### Вплив на область видимості:
```java
public class Example {
    int classVar = 1; // Область видимості - весь клас
    
    public void method() {
        int methodVar = 2; // Область видимості - метод
        
        if (true) {
            int blockVar = 3; // Область видимості - лише цей блок
            System.out.println(classVar);  // OK
            System.out.println(methodVar); // OK
            System.out.println(blockVar);  // OK
        }
        
        // System.out.println(blockVar); // ПОМИЛКА! blockVar не доступна
    }
}
```

## 9. Використання умовних конструкцій

### if
**Коли використовувати**: Проста перевірка однієї умови
```java
if (age >= 18) {
    System.out.println("Повнолітній");
}
```

### if-else
**Коли використовувати**: Вибір між двома альтернативами
```java
if (score >= 60) {
    System.out.println("Склав");
} else {
    System.out.println("Не склав");
}
```

### Ланцюги if-else if
**Коли використовувати**: Множинний вибір із складними умовами
```java
if (grade >= 90) {
    System.out.println("A");
} else if (grade >= 80) {
    System.out.println("B");
} else if (grade >= 70) {
    System.out.println("C");
} else {
    System.out.println("F");
}
```

### switch
**Коли використовувати**: Множинний вибір за конкретним значенням
```java
switch (dayOfWeek) {
    case 1: System.out.println("Понеділок"); break;
    case 2: System.out.println("Вівторок"); break;
    case 3: System.out.println("Середа"); break;
}
```

### Тернарна операція ?:
**Коли використовувати**: Простий вибір між двома значеннями
```java
String result = (score >= 60) ? "Склав" : "Не склав";
int max = (a > b) ? a : b;
```

## 10. Використання циклів

### while
**Коли використовувати**: Коли кількість ітерацій невідома заздалегідь
```java
Scanner scanner = new Scanner(System.in);
String input = "";
while (!input.equals("exit")) {
    input = scanner.nextLine();
    // обробка введення
}
```

### do-while
**Коли використовувати**: Коли потрібно виконати код хоча б один раз
```java
int userChoice;
do {
    System.out.println("Виберіть опцію (1-5):");
    userChoice = scanner.nextInt();
} while (userChoice < 1 || userChoice > 5);
```

### for
**Коли використовувати**: Коли кількість ітерацій відома або працюємо з колекціями
```java
// Відома кількість ітерацій
for (int i = 0; i < 10; i++) {
    System.out.println(i);
}

// Робота з масивом
for (int num : numbers) {
    System.out.println(num);
}
```

## 11. break vs continue

### break
- **Призначення**: Повністю виходить з циклу
- **Дія**: Перериває виконання циклу і передає управління наступній інструкції після циклу

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break; // Вихід з циклу при i = 5
    }
    System.out.println(i); // Виведе: 0, 1, 2, 3, 4
}
```

### continue
- **Призначення**: Пропускає поточну ітерацію і переходить до наступної
- **Дія**: Перериває поточну ітерацію, але цикл продовжується

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        continue; // Пропускає ітерацію при i = 5
    }
    System.out.println(i); // Виведе: 0, 1, 2, 3, 4, 6, 7, 8, 9
}
```

## 12. Навіщо мітки в Java без goto?

**Мітки (Labels)** потрібні для керування вкладеними циклами з операторами `break` та `continue`.

### Використання:
```java
outer: for (int i = 0; i < 5; i++) {
    inner: for (int j = 0; j < 5; j++) {
        if (i == 2 && j == 2) {
            break outer; // Вихід з зовнішнього циклу
        }
        System.out.println(i + ", " + j);
    }
}
```

### Переваги:
- Контрольований вихід з вкладених циклів
- Альтернатива складним boolean змінним
- Збереження структурованості коду

## 13. Аналіз коду з присвоєнням в умовах

```java
boolean a = false;
boolean b = false;
if (a = false) {          // Присвоєння false, умова false
    System.out.println("a is false");
}
if (b = true) {           // Присвоєння true, умова true
    System.out.println("b is true");
}
if (a = b) {              // Присвоєння b до a (true), умова true
    System.out.println("a = b");
}
```

### Результат:
```
b is true
a = b
```

### Пояснення:
- Перший `if`: `a = false` присвоює false і повертає false → блок не виконується
- Другий `if`: `b = true` присвоює true і повертає true → блок виконується
- Третій `if`: `a = b` присвоює значення b (true) до a і повертає true → блок виконується

## 14. Аналіз switch без break

```java
int a = 1;
a++;      // a = 2
++a;      // a = 3
switch(a) {
    case 1: System.out.println("1");
    case 2: System.out.println("2");
    case 3: System.out.println("3");
    case 4: System.out.println("4");
}
```

### Результат:
```
3
4
```

### Пояснення:
- Після інкрементів: a = 3
- Switch переходить до `case 3:`
- Відсутність `break` призводить до "провалювання" (fall-through)
- Виконуються всі наступні case до кінця switch

## 15. Аналіз цілочисельного ділення

```java
double sum = 0;
for(int i = 1; i < 10; i++) {
    sum = sum + 1/i;  // Цілочисельне ділення!
}
System.out.println(sum > 1);
```

### Результат: `false`

### Пояснення:
- `1/i` - це **цілочисельне ділення**, оскільки обидва операнди int
- Результати: 1/1=1, 1/2=0, 1/3=0, 1/4=0, ..., 1/9=0
- `sum = 1.0 + 0 + 0 + ... + 0 = 1.0`
- `sum > 1` → `1.0 > 1` → `false`

### Правильний варіант:
```java
sum = sum + 1.0/i;  // або (double)1/i
```